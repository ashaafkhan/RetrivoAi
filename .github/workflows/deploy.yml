name: Terraform AWS Deployment

on:
  push:
    branches:
      - main
      - develop
      - staging
  pull_request:
    branches: [main, staging]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      reset_db_password:
        description: 'Reset database password (use with caution)'
        required: false
        default: false
        type: boolean
      bastion_allowed_cidr:
        description: 'CIDR block allowed to access bastion (e.g. office IP)'
        required: false
        default: '0.0.0.0/0'
        type: string
      wait_for_db:
        description: 'Wait for database to be available before initialization'
        required: false
        default: true
        type: boolean

env:
  TERRAFORM_VERSION: 1.5.7
  PYTHON_VERSION: '3.11'

permissions:
  id-token: write
  contents: read

jobs:
  determine_environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      reset_db_password: ${{ steps.set-env.outputs.reset_db_password }}
      wait_for_db: ${{ steps.set-env.outputs.wait_for_db }}
      project_name: ${{ steps.read-vars.outputs.project_name }}
      aws_region: ${{ steps.read-vars.outputs.aws_region }}
      bastion_allowed_cidr: ${{ steps.read-vars.outputs.bastion_allowed_cidr }}
      enable_lifecycle_rules: ${{ steps.read-vars.outputs.enable_lifecycle_rules }}
    steps:
      - uses: actions/checkout@v4
      - id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            BRANCH="${GITHUB_REF##*/}"
            case "$BRANCH" in
              main) ENV="prod" ;;
              staging) ENV="staging" ;;
              develop) ENV="dev" ;;
              *) ENV="dev" ;;  # fallback default
            esac
            echo "environment=$ENV" >> $GITHUB_OUTPUT
          fi
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.reset_db_password }}" == "true" ]]; then
            echo "reset_db_password=true" >> $GITHUB_OUTPUT
          else
            echo "reset_db_password=false" >> $GITHUB_OUTPUT
          fi
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.wait_for_db }}" == "false" ]]; then
            echo "wait_for_db=false" >> $GITHUB_OUTPUT
          else
            echo "wait_for_db=true" >> $GITHUB_OUTPUT
          fi
      - id: read-vars
        run: |
          ENV="${{ steps.set-env.outputs.environment }}"
          echo "Using environment: $ENV"
          
          if [ -f "environments/$ENV/terraform.tfvars" ]; then
            PROJECT_NAME=$(grep project_name environments/$ENV/terraform.tfvars | cut -d '=' -f2 | tr -d ' "')
            AWS_REGION=$(grep aws_region environments/$ENV/terraform.tfvars | cut -d '=' -f2 | tr -d ' "')
          else
            echo "Warning: terraform.tfvars file not found for environment $ENV"
          fi
          
          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "aws_region=$AWS_REGION" >> $GITHUB_OUTPUT
          
          if [[ "$ENV" == "prod" ]]; then
            echo "enable_lifecycle_rules=true" >> $GITHUB_OUTPUT
          else
            echo "enable_lifecycle_rules=false" >> $GITHUB_OUTPUT
          fi
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.bastion_allowed_cidr }}" ]]; then
            echo "bastion_allowed_cidr=${{ github.event.inputs.bastion_allowed_cidr }}" >> $GITHUB_OUTPUT
          else
            echo "bastion_allowed_cidr=0.0.0.0/0" >> $GITHUB_OUTPUT
          fi

  code-quality:
    name: SonarQube
    runs-on: ubuntu-latest
    needs: [determine_environment]
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Install tox and any other packages
        run: pip install tox
      - name: Run tox
        run: tox -e py
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    continue-on-error: true

  build_lambda:
    needs: [determine_environment]
    runs-on: ubuntu-latest
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
      STAGE: ${{ needs.determine_environment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '${{ env.PYTHON_VERSION }}'
      - name: Cache pip
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
      - name: Package Lambda functions
        run: |
          mkdir -p lambda_artifacts
          LAMBDA_DIRS=("document_processor" "query_processor" "upload_handler" "db_init" "auth_handler")
          for DIR in "${LAMBDA_DIRS[@]}"; do
            if [ -d "src/$DIR" ]; then
              echo "Packaging $DIR Lambda"
              cd src/$DIR && pip install -r requirements.txt -t . || true && zip -r ../../lambda_artifacts/$DIR.zip . && cd ../..
            fi
          done
      - name: Upload Lambda artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lambda-artifacts
          path: lambda_artifacts/
          retention-days: 1

  terraform-plan:
    needs: [determine_environment, build_lambda]
    runs-on: ubuntu-latest
    environment: ${{ needs.determine_environment.outputs.environment }}
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      STAGE: ${{ needs.determine_environment.outputs.environment }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ needs.determine_environment.outputs.aws_region }}
      - name: Create Backend Configuration
        run: |
          cd environments/$STAGE
          cat > backend.tf << EOF
          terraform {
            backend "s3" {
              bucket                  = "${PROJECT_NAME}-terraform-state"
              key                     = "${STAGE}/terraform.tfstate"
              region                  = "${AWS_REGION}"
              dynamodb_table          = "${PROJECT_NAME}-${STAGE}-terraform-state-lock"
              encrypt                 = true
              skip_credentials_validation = true
              skip_metadata_api_check     = true
              force_path_style            = true
            }
          }
          EOF
          cd ../..
      - name: Create Terraform State Bucket and DynamoDB Table
        run: |
          BUCKET_NAME="${PROJECT_NAME}-terraform-state"
          DYNAMODB_TABLE="${PROJECT_NAME}-${STAGE}-terraform-state-lock"
          aws s3api head-bucket --bucket $BUCKET_NAME 2>/dev/null || aws s3api create-bucket --bucket $BUCKET_NAME --region $AWS_REGION
          aws s3api put-bucket-versioning --bucket $BUCKET_NAME --versioning-configuration Status=Enabled
          aws dynamodb describe-table --table-name $DYNAMODB_TABLE 2>/dev/null || aws dynamodb create-table --table-name $DYNAMODB_TABLE --attribute-definitions AttributeName=LockID,AttributeType=S --key-schema AttributeName=LockID,KeyType=HASH --billing-mode PAY_PER_REQUEST
      - name: Download Lambda artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-artifacts
          path: lambda_artifacts/
      - name: Upload Lambda ZIP files to S3
        run: |
          LAMBDA_BUCKET_NAME="${PROJECT_NAME}-${STAGE}-lambda-code"
          aws s3api head-bucket --bucket ${LAMBDA_BUCKET_NAME} 2>/dev/null || aws s3api create-bucket --bucket ${LAMBDA_BUCKET_NAME} --region ${AWS_REGION}
          aws s3 cp lambda_artifacts/ s3://${LAMBDA_BUCKET_NAME}/lambda/ --recursive
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      - name: Terraform Init
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: terraform init
      - name: Terraform Plan
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: |
          terraform plan -lock=false -var="reset_db_password=${{ needs.determine_environment.outputs.reset_db_password }}" -var="enable_lifecycle_rules=${{ needs.determine_environment.outputs.enable_lifecycle_rules }}" -var="bastion_allowed_cidr=[\"${{ needs.determine_environment.outputs.bastion_allowed_cidr }}\"]" -out=tfplan
      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ needs.determine_environment.outputs.environment }}
          path: environments/${{ needs.determine_environment.outputs.environment }}/tfplan
          retention-days: 1

  terraform-apply:
    needs: [determine_environment, build_lambda, terraform-plan]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment: ${{ needs.determine_environment.outputs.environment }}
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      STAGE: ${{ needs.determine_environment.outputs.environment }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
      RESET_DB_PASSWORD: ${{ needs.determine_environment.outputs.reset_db_password }}
      WAIT_FOR_DB: ${{ needs.determine_environment.outputs.wait_for_db }}
    outputs:
      api_endpoint: ${{ steps.terraform-apply.outputs.api_endpoint }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ needs.determine_environment.outputs.aws_region }}
      - name: Download Lambda artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-artifacts
          path: lambda_artifacts/
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ needs.determine_environment.outputs.environment }}
          path: environments/${{ needs.determine_environment.outputs.environment }}
      - name: Terraform Init
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: terraform init
      - name: Terraform Apply
        id: terraform-apply
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: |
            terraform apply -auto-approve tfplan | tee apply_output.txt
            sleep 2
            COGNITO_CLIENT_ID=$(grep -m1 "cognito_app_client_id" apply_output.txt | sed -E 's/.*= "?([^"]+)"?.*/\1/' || echo "")
            API_ENDPOINT=$(grep -m1 "api_endpoint" apply_output.txt | sed -E 's/.*= "?([^"]+)"?.*/\1/' || echo "")
            echo "COGNITO_CLIENT_ID=$COGNITO_CLIENT_ID" > ../../env_vars.env
            echo "API_ENDPOINT=$API_ENDPOINT" >> ../../env_vars.env
            echo "api_endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT
      - name: Upload UI Env File as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ui-env-vars
          path: env_vars.env
      - name: Wait for RDS instance to be available
        if: ${{ needs.determine_environment.outputs.wait_for_db == 'true' }}
        run: |
          DB_INSTANCE_ID="${PROJECT_NAME}-${STAGE}-postgres"
          MAX_ATTEMPTS=60
          ATTEMPT=1
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            STATUS=$(aws rds describe-db-instances --db-instance-identifier $DB_INSTANCE_ID --region $AWS_REGION --query "DBInstances[0].DBInstanceStatus" --output text 2>/dev/null || echo "not-found")
            if [ "$STATUS" = "available" ]; then break; fi
            ATTEMPT=$((ATTEMPT+1))
            sleep 10
          done
      - name: Update Lambda env vars if DB password was reset
        if: ${{ needs.determine_environment.outputs.reset_db_password == 'true' }}
        run: |
          DB_SECRET_ARN=$(terraform output -raw db_credentials_secret_arn 2>/dev/null || echo "")
          if [ -n "$DB_SECRET_ARN" ]; then
            FUNCTION_NAMES=("document_processor" "query_processor" "upload_handler" "db_init" "auth_handler")
            for FUNCTION_NAME in "${FUNCTION_NAMES[@]}"; do
              aws lambda update-function-configuration --function-name "$FUNCTION_NAME" --environment "Variables={DB_SECRET_ARN=$DB_SECRET_ARN}"
            done
          fi
      - name: Verify deployment
        run: |
          UPLOAD_HANDLER_NAME="${PROJECT_NAME}-${STAGE}-upload-handler"
          aws lambda invoke --function-name $UPLOAD_HANDLER_NAME --payload '{"action": "healthcheck"}' response.json || echo "Verification failed"
          cat response.json || echo "Could not get response"

  integration_tests:
    needs: [determine_environment, terraform-apply]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment: ${{ needs.determine_environment.outputs.environment }}
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      STAGE: ${{ needs.determine_environment.outputs.environment }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
      API_ENDPOINT: ${{ needs.terraform-apply.outputs.api_endpoint }}
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ needs.determine_environment.outputs.aws_region }}
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
      - name: Run integration tests
        run: |
          if [ "$API_ENDPOINT" == "https://example.com" ]; then
            echo "Skipping integration tests"
          else
            python src/tests/integration/run_integration_tests.py
          fi
      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: integration-test-results.xml
