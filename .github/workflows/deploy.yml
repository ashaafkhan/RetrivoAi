name: Terraform AWS Deployment

on:
  push:
    branches:
      - main
      - develop
      - staging
  pull_request:
    branches: [main, staging]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      reset_db_password:
        description: 'Reset database password (use with caution)'
        required: false
        default: false
        type: boolean
      bastion_allowed_cidr:
        description: 'CIDR block allowed to access bastion (e.g. office IP)'
        required: false
        default: '0.0.0.0/0'
        type: string
      wait_for_db:
        description: 'Wait for database to be available before initialization'
        required: false
        default: true
        type: boolean

env:
  TERRAFORM_VERSION: 1.5.7
  PYTHON_VERSION: '3.11'

permissions:
  id-token: write
  contents: read

jobs:
  determine_environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      reset_db_password: ${{ steps.set-env.outputs.reset_db_password }}
      wait_for_db: ${{ steps.set-env.outputs.wait_for_db }}
      project_name: ${{ steps.read-vars.outputs.project_name }}
      aws_region: ${{ steps.read-vars.outputs.aws_region }}
      bastion_allowed_cidr: ${{ steps.read-vars.outputs.bastion_allowed_cidr }}
      enable_lifecycle_rules: ${{ steps.read-vars.outputs.enable_lifecycle_rules }}
    steps:
      - uses: actions/checkout@v4
      - id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            BRANCH="${GITHUB_REF##*/}"
            case "$BRANCH" in
              main) ENV="prod" ;;
              staging) ENV="staging" ;;
              develop) ENV="dev" ;;
              *) ENV="dev" ;;  # fallback default
            esac
            echo "environment=$ENV" >> $GITHUB_OUTPUT
          fi
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.reset_db_password }}" == "true" ]]; then
            echo "reset_db_password=true" >> $GITHUB_OUTPUT
          else
            echo "reset_db_password=false" >> $GITHUB_OUTPUT
          fi
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.wait_for_db }}" == "false" ]]; then
            echo "wait_for_db=false" >> $GITHUB_OUTPUT
          else
            echo "wait_for_db=true" >> $GITHUB_OUTPUT
          fi
  
      - id: read-vars
        run: |
          ENV="${{ steps.set-env.outputs.environment }}"
          echo "Using environment: $ENV"
          
          if [ -f "environments/$ENV/terraform.tfvars" ]; then
            PROJECT_NAME=$(grep project_name environments/$ENV/terraform.tfvars | cut -d '=' -f2 | tr -d ' "')
            AWS_REGION=$(grep aws_region environments/$ENV/terraform.tfvars | cut -d '=' -f2 | tr -d ' "')
          else
            echo "Warning: terraform.tfvars file not found for environment $ENV"
          fi
          
          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "aws_region=$AWS_REGION" >> $GITHUB_OUTPUT
          
          if [[ "$ENV" == "prod" ]]; then
            echo "enable_lifecycle_rules=true" >> $GITHUB_OUTPUT
          else
            echo "enable_lifecycle_rules=false" >> $GITHUB_OUTPUT
          fi
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.bastion_allowed_cidr }}" ]]; then
            echo "bastion_allowed_cidr=${{ github.event.inputs.bastion_allowed_cidr }}" >> $GITHUB_OUTPUT
          else
            echo "bastion_allowed_cidr=0.0.0.0/0" >> $GITHUB_OUTPUT
          fi

  code-quality:
    name: SonarQube
    runs-on: ubuntu-latest
    needs: [determine_environment]
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Install tox and any other packages
        run: pip install tox
      - name: Run tox
        run: tox -e py
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    continue-on-error: true
    
  build_lambda:
    needs: [determine_environment]
    runs-on: ubuntu-latest
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
      STAGE: ${{ needs.determine_environment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '${{ env.PYTHON_VERSION }}'
      - name: Cache pip
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
      - name: Package Lambda functions
        run: |
          mkdir -p lambda_artifacts
          LAMBDA_DIRS=("document_processor" "query_processor" "upload_handler" "db_init" "auth_handler")
          for DIR in "${LAMBDA_DIRS[@]}"; do
            if [ -d "src/$DIR" ]; then
              echo "Packaging $DIR Lambda"
              cd src/$DIR && pip install -r requirements.txt -t . || true && zip -r ../../lambda_artifacts/$DIR.zip . && cd ../..
            fi
          done
      - name: Upload Lambda artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lambda-artifacts
          path: lambda_artifacts/
          retention-days: 1

  terraform-plan:
    needs: [determine_environment, build_lambda]
    runs-on: ubuntu-latest
    environment: ${{ needs.determine_environment.outputs.environment }}
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      STAGE: ${{ needs.determine_environment.outputs.environment }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ needs.determine_environment.outputs.aws_region }}
      - name: Terraform Init
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: terraform init
      - name: Terraform Plan
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: terraform plan -lock=false -out=tfplan
      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ needs.determine_environment.outputs.environment }}
          path: environments/${{ needs.determine_environment.outputs.environment }}/tfplan
          retention-days: 1

  terraform-apply:
    needs: [determine_environment, build_lambda, terraform-plan]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment: ${{ needs.determine_environment.outputs.environment }}
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      STAGE: ${{ needs.determine_environment.outputs.environment }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
    outputs:
      api_endpoint: ${{ steps.terraform-apply.outputs.api_endpoint }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ needs.determine_environment.outputs.aws_region }}
      - name: Download Lambda artifacts
        uses: actions/download-artifact@v4
        with:
          name: lambda-artifacts
          path: lambda_artifacts/
      - name: Terraform Apply
        id: terraform-apply
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: terraform apply -auto-approve tfplan | tee apply_output.txt
      - name: Extract and Set API Endpoint
        run: |
            API_ENDPOINT=$(grep -m1 "api_endpoint" apply_output.txt | sed -E 's/.*= "?([^"]+)"?.*/\1/' || echo "")
            echo "api_endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT
      - name: Upload UI Env File as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ui-env-vars
          path: env_vars.env
      - name: Verify deployment
        run: |
          UPLOAD_HANDLER_NAME="${PROJECT_NAME}-${STAGE}-upload-handler"
          echo "Verifying deployment by invoking ${UPLOAD_HANDLER_NAME}..."
          aws lambda invoke --function-name $UPLOAD_HANDLER_NAME --payload '{"action": "healthcheck"}' response.json || echo "Verification failed"
          cat response.json || echo "Could not get response"
