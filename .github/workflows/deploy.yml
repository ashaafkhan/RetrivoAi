name: Terraform AWS Deployment

on:
  push:
    branches:
      - main
      - develop
      - staging
  pull_request:
    branches: [main, staging]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      reset_db_password:
        description: 'Reset database password (use with caution)'
        required: false
        default: false
        type: boolean
      bastion_allowed_cidr:
        description: 'CIDR block allowed to access bastion (e.g. office IP)'
        required: false
        default: '0.0.0.0/0'
        type: string
      wait_for_db:
        description: 'Wait for database to be available before initialization'
        required: false
        default: true
        type: boolean

env:
  TERRAFORM_VERSION: 1.5.7
  PYTHON_VERSION: '3.11'

permissions:
  id-token: write
  contents: read

jobs:
  determine_environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      reset_db_password: ${{ steps.set-env.outputs.reset_db_password }}
      wait_for_db: ${{ steps.set-env.outputs.wait_for_db }}
      project_name: ${{ steps.read-vars.outputs.project_name }}
      aws_region: ${{ steps.read-vars.outputs.aws_region }}
      bastion_allowed_cidr: ${{ steps.read-vars.outputs.bastion_allowed_cidr }}
      enable_lifecycle_rules: ${{ steps.read-vars.outputs.enable_lifecycle_rules }}
    steps:
      - uses: actions/checkout@v4

      - id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            BRANCH="${GITHUB_REF##*/}"
            case "$BRANCH" in
              main) ENV="prod" ;;
              staging) ENV="staging" ;;
              develop) ENV="dev" ;;
              *) ENV="dev" ;;  # fallback default
            esac
            echo "environment=$ENV" >> $GITHUB_OUTPUT
          fi
          
          # Default to NOT resetting DB password unless explicitly triggered
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.reset_db_password }}" == "true" ]]; then
            echo "reset_db_password=true" >> $GITHUB_OUTPUT
          else
            echo "reset_db_password=false" >> $GITHUB_OUTPUT
          fi
          
          # Set wait_for_db flag from input or default to true
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.wait_for_db }}" == "false" ]]; then
            echo "wait_for_db=false" >> $GITHUB_OUTPUT
          else
            echo "wait_for_db=true" >> $GITHUB_OUTPUT
          fi

      - id: read-vars
        run: |
          ENV="${{ steps.set-env.outputs.environment }}"
          echo "Using environment: $ENV"

          if [ -f "environments/$ENV/terraform.tfvars" ]; then
            PROJECT_NAME=$(grep project_name environments/$ENV/terraform.tfvars | cut -d '=' -f2 | tr -d ' "')
            AWS_REGION=$(grep aws_region environments/$ENV/terraform.tfvars | cut -d '=' -f2 | tr -d ' "')
          else
            echo "Warning: terraform.tfvars file not found for environment $ENV"
          fi

          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "aws_region=$AWS_REGION" >> $GITHUB_OUTPUT
          
          if [[ "$ENV" == "prod" ]]; then
            echo "enable_lifecycle_rules=true" >> $GITHUB_OUTPUT
          else
            echo "enable_lifecycle_rules=false" >> $GITHUB_OUTPUT
          fi

          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.bastion_allowed_cidr }}" ]]; then
            echo "bastion_allowed_cidr=${{ github.event.inputs.bastion_allowed_cidr }}" >> $GITHUB_OUTPUT
          else
            echo "bastion_allowed_cidr=0.0.0.0/0" >> $GITHUB_OUTPUT
          fi

  terraform-plan:
    needs: [determine_environment]
    runs-on: ubuntu-latest
    environment: ${{ needs.determine_environment.outputs.environment }}
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      STAGE: ${{ needs.determine_environment.outputs.environment }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ needs.determine_environment.outputs.aws_region }}

      - name: Create Backend Configuration 
        run: |
          cd environments/$STAGE
          cat > backend.tf << EOF
          terraform {
            backend "s3" {
              bucket                  = "${PROJECT_NAME}-terraform-state-$(date +%s)"
              key                     = "${STAGE}/terraform.tfstate"
              region                  = "${AWS_REGION}"
              dynamodb_table          = "${PROJECT_NAME}-${STAGE}-terraform-state-lock"
              encrypt                 = true
              skip_credentials_validation = true
              skip_metadata_api_check     = true
              force_path_style            = true
            }
          }
          EOF
          cd ../..

      - name: Create S3 Bucket and DynamoDB Table
        run: |
          BUCKET_NAME="${PROJECT_NAME}-terraform-state-$(date +%s)"
          DYNAMODB_TABLE="${PROJECT_NAME}-${STAGE}-terraform-state-lock"

          echo "Creating S3 bucket $BUCKET_NAME..."
          aws s3api head-bucket --bucket $BUCKET_NAME 2>/dev/null || \
            aws s3api create-bucket --bucket $BUCKET_NAME --region $AWS_REGION \
            $(if [[ "$AWS_REGION" != "us-east-1" ]]; then echo "--create-bucket-configuration LocationConstraint=$AWS_REGION"; fi)

          echo "Enabling versioning on bucket $BUCKET_NAME..."
          aws s3api put-bucket-versioning --bucket $BUCKET_NAME --versioning-configuration Status=Enabled

          echo "Creating DynamoDB table $DYNAMODB_TABLE..."
          aws dynamodb describe-table --table-name $DYNAMODB_TABLE 2>/dev/null || \
            aws dynamodb create-table --table-name $DYNAMODB_TABLE --attribute-definitions \
            AttributeName=LockID,AttributeType=S --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      
      - name: Terraform Init
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: terraform init

      - name: Terraform Plan
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: |
          terraform plan \
            -lock=false \
            -var="reset_db_password=${{ needs.determine_environment.outputs.reset_db_password }}" \
            -var="enable_lifecycle_rules=${{ needs.determine_environment.outputs.enable_lifecycle_rules }}" \
            -var="bastion_allowed_cidr=[\"${{ needs.determine_environment.outputs.bastion_allowed_cidr }}\"]" \
            -out=tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ needs.determine_environment.outputs.environment }}
          path: environments/${{ needs.determine_environment.outputs.environment }}/tfplan
          retention-days: 1

  terraform-apply:
    needs: [determine_environment, terraform-plan]
    runs-on: ubuntu-latest
    environment: ${{ needs.determine_environment.outputs.environment }}
    env:
      PROJECT_NAME: ${{ needs.determine_environment.outputs.project_name }}
      STAGE: ${{ needs.determine_environment.outputs.environment }}
      AWS_REGION: ${{ needs.determine_environment.outputs.aws_region }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ needs.determine_environment.outputs.aws_region }}

      - name: Terraform Init
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: terraform init

      - name: Terraform Apply
        id: terraform-apply
        working-directory: environments/${{ needs.determine_environment.outputs.environment }}
        run: |
            terraform apply -auto-approve tfplan | tee apply_output.txt

            # Extract endpoint details
            API_ENDPOINT=$(grep -m1 "api_endpoint" apply_output.txt | sed -E 's/.*= "?([^"]+)"?.*/\1/' || echo "")
            echo "api_endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT

      - name: Upload UI Env File as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ui-env-vars
          path: env_vars.env
